1. JAVA КАТО ЕЗИК ЗА ПРОГРАМИРАНЕ

	1.1 строго типизиран език		-> променливите имат даден тип
	
	1.2 императивен език			-> описва се точно действое по действие как работи програмата
	
	1.3 обектно-ориентирам език		
	
	1.4 event-driven 				-> трябва да направим нещо (да натиснем бутон, да подвижим мишката...) за да стане нещо
	
	1.5 език от високо ниво			-> за разлика от езиците от ниско ниво, не е силно обвързан с ахритектурата (хардуера) на 
										компютъра
										
	1.6 компилиран и интерпретиран	
			а. компилация -> кода се компилира до bytecode (.class)
			б. интерпретация -> пуска се чрез JVM (Java Virtual Machine)
			
	1.7 platform indepenent език
			-> файлът .java се компилра от Java Compiler до файл .class
			-> след това този файл може да се пусне на всякакви машини без значение от тяхната операционна система
			
	1.8 Java Runtime Ervironment (JRE)
			-> съдържа JVM и java class библиотеки
			-> чете bytecode (.class)
			-> стартира .class навсякъде където има JVM
			
	1.9 Java Development Kit (JDK)
			-> включва JRE, Java Compiler
			-> компилира bytecode (.java -> .class)
	
	1.10 Integrated Development Environent (IDE)
			-> предоставя среда за разработка, където може да се пише код, да се дебъгва, за се оправляват проекти
			
			
			
2.ПРОМЕЛНИВИ И ТИПОВЕ ДАННИ

	2.1 типове данни:
			а. boolean  -> true/false
			б. int  -> целичослени данни
			в. double  -> дробни числа
					double x = 9/2;	-> това връща 4
					double x = 9/2.0;	-> това вече връща 4.5
			г. string  -> “низове” - поредица от символи (неопределен брой)
					String greeting = “Hello World!”;	-> кавичките са задължителни
					-> ДВОЙНИ КАВИЧКИ
					-> ГЛАВНА ПЪРВА БУКВА
					String gr1 = “Hello”, gr2 = “World”;
					System.out.println(gr1 + “ “ + gr2 + “!”);
					(4-5) изкарва Hello World!
					-> gr1.length() -> взима дължината на стринга
					-> gr1.substring(0,5) -> взима от 0вия до 5тия символ
					-> gr1.toUpperCase() -> прави всичко главни букви
					-> gr1.toLowerCase() -> прави всичко малки букви
					-> gr1.compareTo(gr2) -> <0 ако gr1 e по-малко; 0 ако gr1 е колкото gr2; >0 aко gr1 е повече от gr2
					-> gr1.equalsTo(gr2) -> true/false
					-> gr1.indexOf(‘l’) -> на кой индекс е този символ (може да се сложи и променлива char в скобите)
						gr1 = “Hello” + 3; => Hello3
						gr1 = “Hello” + 1 + 2 + 3; => Hello123
						gr1 = “Hello” + (1 + 2 + 3); => Hello6
			д. long  -> за да декларираме променлива от тип long трябва след зададената стойност да сложим L/l иначе компютъра ще я приеме като int
					long x = 1234567890L;
			е. byte  -> 256 възможни стойности (от -128 до + 127)
					byte y = 127;	y++;	-> това ще изведе -128
			ж. float  -> като double но 2 пъти по малка, за да се използва трябва да се добави F/f след стойността й
					float x = 3,14F;
					-> не се използва почти никога
			з. char  -> тип стрингова променлива, която съдържа САМО един символ
					char x = ‘S’;
					char y = ‘:’;  ….
					-> ЕДИНИЧНИ КАВИЧКИ
	
	2.2 декларация на променлива:
			а. една променлива не може да се декларира два пъти
			б. не е хубаво да се задават едни и същи имена на два типа данни
					itn x = 20;
					double x = 4.5;
			в. имената на променливите не може да започват с цифра и да са ключови думи от езика java (continue, …)
			г. името на променливата трябва да започва с малка буква, а всяка следваща дума да е с главна буква
			д. името не трябва да е прекалено дълго, но да е ясно какво върши дадената променлива
			е. ако пред типа на дадената данна добавим final, това прави тази данна “непроменима” - даваме й 
				стойност при декларацията и след това не може да я променяме надолу по кода (правим я константа)
			ж. тези “константи” обикновено се пишат изцяло с главни букви

	2.3 математически операции:
			+   -> събиране
			-   -> изваждане
			*   -> умножение
			/   -> деление
			+=   -> увеличава стойността на променливата отляво с тази на променливата отдясно
			-=   -> намалява стойността на променливата отляво с тази на променливата отдясно
			*=   -> умножава стойността на променливата отляво с тази на променливата отдясно
			/=   -> дели стойността на променливата отляво с тази на променливата отдясно -> ЦЕЛОЧИСЛЕНО ДЕЛЕНИЕ
			% - > дава остатък
			++   -> увеличава променливата с 1
					а = б++;	-> а=б и след това б=б+1
					а = ++б;	-> б=б+1 и след това а=б
			--   -> същото като ++, само че намалява с 1
			
	2.4 cast-ване на променливи	-> променяне на променливата от един тип в друг
			int x = 12.95; 	-> грешно
			int x = (int)12.95;	-> x=12

	2.5 смятане с различни типове данни	-> след като компютърът срещаме по-голям тип данни автоматично смята резултата 
		като такъв тип
			int ageYears = 32;
			int ageDays = ageYears * 365;
			long ageSeconds = ageYears * 365 * 24L * 60 * 60   -> цялостния резултат ще е long

	2.6 други операции
			\t -> tab
			\b -> backspace
			\n -> нов ред
			\r -> връща се в началото на реда
			\’ => ‘
			\” => “
			\\ -> \

			
			
3. ВХОД И ИЗХОД НА ДАННИ

	3.1 стандартен вход
			-> импортва се import java.util.Scanner;
			Scanner sc = new Scanner(System.in);
			int x = sc.nextInt();
			double y = sc.nextDuoble();
			String z = sc.next();
			
	3.2 добавяне на текстов документ
			а. file -> import > general -> file system -> намираш папката и в дясно трябва да ти излезе файла
			б. четене то добавения файл
					Scanner sc = new Scanner(*the_name_of_the_program*.class.
							getResourceAsStream("*the_name_of_the_file*"));
							
	3.3 добавяне на "диалог
			а. JOptionPane.showInputDialog(“...”)	-> за “диалог” с потребителя
					String input = JOptionPane.showInputDialog("What's your name?");
					-> САМО STRING
					-> ако искаме да въведем число и програмата да го зачете за число (проверява дали целия string не е число)	
							int input = Integer.parseInt(JOptionPane.showInputDialog("..."));
					String[] desserts = {"Icecream", "Cake", "Chocolate"}; 
					String input = (String)JOptionPane.showInputDialog(null, "Choosе a dessert", "Desserts", 2, null, desserts, desserts[0]);
						-> това ще ни създаде падащ списък						

					
			
4. ДЕБЪГВАНЕ	

	4.1 цъкаш 2 пъти отляво на реда, на който искаш да ти е break point-a 
	
	4.2 натискаш буболечката до зелената стрелка, с която стартираш попринцип програмата
	
	4.3 зелената стрекла в началото (resume или F8):
			а. 1 break point - програмата продължава докрая
			б. повече от един - програмата продължава до следващия break point
			
	4.4 step over (F6) -> минава на следващия ред
	
	4.5 step into (до step over) -> ако имаме функция проверява дали грешката не е във функцията. иначе би излезнал 
		само резултата от функцията

		
		
5. РАЗКЛОНЕНИ АЛГОРИТМИ

	5.1 булеви променливи и изрази
			а. булева променлива
					boolian isFive = x == 5;	-> true ако х=5; false ако х!=5
			б. булев израз
					y == 6; 	(у равно ли е на 6)
					
	5.2 операции с булеви променливи
			а. > / < 		-> проверява дали променлива отляво е по-голяма/малка от тази вдясно
			б. >= / <= 		-> проверява дали променлива отляво е по-голяма/малка или равна на тази вдясно
			в. == 			-> проверява дали променлива отляво е равна на тази вдясно
			г. !=			-> проверява дали променлива отляво е различна от тази вдясно
			д. !			-> променя стойността на израза пред който е поставено
			е. &&			-> изразите и от двете страни трябва да са вярни за да изведе true
			ж. ||			-> за да изведе true e достатъчно само един от изразите да е верен
			з. ^ (XOR)		-> стойностите (true/false) на двата израза трябва да са различни
			
	5.3	сравняване на Strings
			String x = "Ora";
			String y = "Cle";
			String z = x + z;	(z = "Oracle")
			boolean test = (z == x + y);
					-> това ще изведе false защото == сравнява къде са запазени обектите в паметта
			boolean test = z.equals(x + y);
					-> това вече ще изведе true
					
	5.4 if-else
			a. if ( *управляващ израз* ) {     ако резултата e изпълнен =>
                    *действие1*;
                }
            б. else {                        ако резултата e неизпълнен, лош =>
                    *действие2*;
                }
                        int a;
                        if (cin >> a) {
                            cout << "a = " << a << endl;
                         }
                        else {
                               cout << "kbd is missing \n";
                         }
			в. else if 		-> играе роля на if вложен в else
			
	5.5 switch (израз/селектор) {
            case 3+5 (ако е равно на селектора): 
				*операция1*;
                *операция2*;
                break;
            case *стойност2*:
                *операция3*;
                *операция4*;
                break;
            dafault:
                *операция5*;
                *операция6*;
        }    
				-> В JAVA Е ВЪЗМОЖНО ДА СЕ ИЗПОЛЗВА int, char ИЛИ String В switch-a
				
	5.6 ?: оператор	
			z = (y < x) ? x : y;
				-> ако условието в скобите е вярно => z = x;
				-> ако не е вярно => z = y
			-> това замества
				if (y < x) {
					z = x;
				}
				else {
					z = y;
				}



6. ЦИКЛИ		

	6.1 while (*управляващо условие*) {
			*действие*;  -> многократно повторение       -> оператор за цикъл; оценява се упр. условие
                         -> ако е вярно => изпялнява де еднократно действието
                         -> условието пак се оценява
                         => ... и отнново, докато условието не се окаже грешно
        }
        -> циклите с предусловие може да не бъдат изпълнени НИТО веднъж
        !!! -> действията трябва да влият върху упр. условие
        		while (cin >> cena) {       -> изпълнява се докато се въвеждат данни от клавиатурата
                	total += cena;
                }

    6.2 do ... while      -> оператор за СЛЕДУСЛОВИЕ
       		do {
            	*действие*      -> 1. изпълнява се тялото (еднократно)
                           		-> 2. оценява се условието:
                                	- при "true" минава се към 1.
                                	- при "false" цикълът приключва
       		} while (упр. усл.);
                	-> решението дали ще се повторио действието се взима чак след като то се е изпълнило
                	-> ГАРАНТИРАНО Е че действието ще се изпълни ПОНЕ веднъж
                	
    6.3 for (инициализация; условие; актуализация) {
            *действие*      -> 1. изпълнява се ЕДНОКРАТНО инициализацията
                            -> 2. оценява се условието :
                                - при "true" се минава към 3.
                                - при "false" цикълът приключва
                            -> 3. изпълнява се тялото (еднократно)
                            -> 4. изпълнява се актуализацията
                            -> 5. минава се към 2.
        }
                for (i = 5, x = 3, y = 5;...) {}
                for (cin >> n >> max; --n; ) {
                        -> n се намалява с 1 преди оценката на израза
                        -> функционалността на актуализацията се мести в --n => n се намалява преди да се провери
                    !!! -> цикълът приключва при n = 0
                }
                for (--n; n; n--) {
                        -> n се приема за "true" когато е НЕНУЛЕВО
                }
		
	6.4 break -> безусловно прекратяване на действоето в тялото
                    -> може да се използва и в цикъл, но обикновено е в if
                        int i;
                        for(i = 0; i < 10; i++) {
                            cout << i;
                            if(i = 5) {
                                break;      -> цикълът се прекратява при i=5
                            }
                            cout << ":-)\n";
                        }
		
	6.5 continue -> прекратява итерацията
                    -> може да се използва самостоятелно, но най-често - в цикъл или if
                    -> break прекратява целия цикъл, докато continue прекратява само текущото изпълнение на цикъла => продължава нататък
                        int i;
                        for (i = 0; i < 10; i++) {
                            cout << i;
                            if (i < 5) {
                                continue;
                            }
                            cout << ":-)\n";        -> това се изпълнява при i >= 5
                        }
		
		
		
		
		
		
		